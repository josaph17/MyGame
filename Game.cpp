#include <windows.h> // для цвета
#include<iostream>
#include<iomanip> //для setw
#include<ctime> //для генерации случайных чисел
#include <conio.h> //для _getch()
using namespace std; 
int** CreateArray(int rows, int cols) //выделение памяти
{
    int** arr = new int* [rows];  //переменная arr будет хранить указатель на указатель  
            //мы создаем массив указателей, мы здесь будем хранить указатели  
    for (int i = 0; i < rows; i++)
    {
        arr[i] = new int[cols]; /*в каждый элемент который будет хранить указатель на int мы будем присваивать новый динамический массив, размер массива будет соответсвовать переменной colls*/
        //объявление и создание массива, выделение под него памяти5
    }
    return arr;
}
void DestroyArray(int** arr, int rows, int cols) //полность удаляем нашу ОП после того как поработаем с нашим массивом и он нам станет ненужен
{
    for (int i = 0; i < rows; i++)
    {
        delete[]arr[i];
    }
    delete[]arr;
}
void FillArray(int** arr, int rows, int cols, int k) //ф-я заполнения массива данными, &arr т.к.  ассив меняется и адрес тоже
{
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            arr[i][j] = 0;
        }
    }
    srand((unsigned int)time(NULL));
    for (int p = 0; p < k;)
    {
        int randomRow = rand() % rows;
        int randomCol = rand() % cols;

        if (arr[randomRow][randomCol] == 0)
        {
            arr[randomRow][randomCol] = 1;
            p++;
        }
        else
            continue;
    }
    for (int p = 0; p < 1;)    //для рандомной 2//////////////////////////////////////
    {
        int randomRow = rand() % rows;
        int randomCol = rand() % cols;

        if (arr[randomRow][randomCol] == 0)
        {
            arr[randomRow][randomCol] = 2;
            p++;
        }
        else
            continue;
    }
    for (int p = 0; p < 10;)    //для рандомной 2//////////////////////////////////////
    {
        int randomRow = rand() % rows;
        int randomCol = rand() % cols;

        if (arr[randomRow][randomCol] == 0)
        {
            arr[randomRow][randomCol] = 7; //enemy
            p++;
        }
        else
            continue;
    }
}
void ShowArray(int** const arr, const int rows, const int cols) //вывод массива
{
    system("cls"); //ф-я очистки экрана (консоли)
    HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); //белый
    for (int j = 0; j <= cols+1; j++)
    {
        if ((j==0) || (j==cols+1))
            cout << "+";
        else 
            cout << "--";
    }
    cout << endl;
    for (int i = 0; i < rows; i++)
    {
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); //белый
        cout << "|";
        for (int j = 0; j < cols; j++)
        {
             //для получения дискрипптора
            if (arr[i][j] == 0)
            {
                cout <<"  ";
            }
            if (arr[i][j] == 1)
            {
                SetConsoleTextAttribute(console, FOREGROUND_GREEN | FOREGROUND_INTENSITY); //зеленые
                cout << "[]";
            }
            if (arr[i][j] == 2)
            {
                SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_INTENSITY); //белый
                cout <<"()";
            }
            if (arr[i][j] == 7)
            {
                SetConsoleTextAttribute(console, FOREGROUND_BLUE | FOREGROUND_INTENSITY); //синий
                cout << "**";
            }
        }  
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); //белый
        cout << "|";
        cout << endl;//в конце каждой строки будет отвечать за переход на следующую строчку
    }
    SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); //белый
    for (int j = 0; j <= cols + 1; j++)
    {
        if ((j == 0) || (j == cols + 1))
            cout << "+";
        else
            cout << "--";

    }
    cout << endl;
    /*cout << "Для продолжения работы программы нажмите любую кнопку ";
    cin.get();*/
    cout << endl;
}
void ChangeDown(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows - 1; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = 0; j < cols; j++)
        {
            if ((arr[i][j] == 2) && (arr[i + 1][j] == 0))
            {
                arr[i][j] = 0;
                arr[i + 1][j] = 2;          
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 2) && (arr[i + 1][j] == 7))
            {
                arr[i][j] = 7;
                arr[i + 1][j] = 0;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void ChangeUp(int** const arr, const int rows, const int cols)
{
    for (int i = rows-1; i>0; i--) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов  
        /*_____число rows меняется_____*/
    { 
        for (int j = 0; j < cols; j++)
        {
            if ((arr[i][j] == 2) && (arr[i - 1][j] == 0))
            {
                arr[i][j] = 0;
                arr[i - 1][j] = 2;          
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 2) && (arr[i - 1][j] == 7))
            {
                arr[i][j] = 7;
                arr[i - 1][j] = 0;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void ChangeRight(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = 0; j < cols-1; j++)
        {
            if ((arr[i][j] == 2) && (arr[i][j + 1] == 0))
            {
                arr[i][j] = 0;
                arr[i][j + 1] = 2;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 2) && (arr[i][j + 1] == 7))
            {
                arr[i][j] = 7;
                arr[i][j + 1] = 0;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void ChangeLeft(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = cols-1; j >0; j--)
        {
            if ((arr[i][j] == 2) && (arr[i][j - 1] == 0))
            {
                arr[i][j] = 0;
                arr[i][j - 1] = 2;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 2) && (arr[i][j - 1] == 7))
            {
                arr[i][j] = 7;
                arr[i][j - 1] = 0;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
//Enemy
void EnemyDown(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows - 1; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = 0; j < cols; j++)
        {
            if ((arr[i][j] == 7) && (arr[i + 1][j] == 0))
            {
                arr[i][j] = 0;
                arr[i + 1][j] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 7) && (arr[i + 1][j] == 2))
            {
                arr[i][j] = 0;
                arr[i + 1][j] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void EnemyUp(int** const arr, const int rows, const int cols)
{
    for (int i = rows - 1; i > 0; i--) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов  
        /*_____число rows меняется_____*/
    {
        for (int j = 0; j < cols; j++)
        {
            if ((arr[i][j] == 7) && (arr[i - 1][j] == 0))
            {
                arr[i][j] = 0;
                arr[i - 1][j] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 7) && (arr[i - 1][j] == 2))
            {
                arr[i][j] = 0;
                arr[i - 1][j] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void EnemyRight(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = 0; j < cols - 1; j++)
        {
            if ((arr[i][j] == 7) && (arr[i][j + 1] == 0))
            {
                arr[i][j] = 0;
                arr[i][j + 1] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 7) && (arr[i][j + 1] == 2))
            {
                arr[i][j] = 0;
                arr[i][j + 1] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void EnemyLeft(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows; i++) // ограничение на последнюю строку (rows - 1), т.к. под последней строкой не может быть эл-ов 
    {
        for (int j = cols - 1; j > 0; j--)
        {
            if ((arr[i][j] == 7) && (arr[i][j - 1] == 0))
            {
                arr[i][j] = 0;
                arr[i][j - 1] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
            if ((arr[i][j] == 7) && (arr[i][j - 1] == 2))
            {
                arr[i][j] = 0;
                arr[i][j - 1] = 7;
                return; // этот оператор нужен нам чтобы выйти из ф-ии, чтобы цикл прошел 1 раз и вышел
            }
        }
    }
}
void RandomEnemyMove(int** const arr, const int rows, const int cols)
{
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            if (arr[i][j] == 7)
            {
                srand((unsigned int)time(NULL));
                int randomMove = 1 + rand() % 4;
                switch (randomMove)
                {
                case 1:
                    EnemyDown(arr, rows, cols);
                case 2:
                    EnemyUp(arr, rows, cols);
                    break;
                case 3:
                    EnemyRight(arr, rows, cols);
                    break;

                case 4:
                    EnemyLeft(arr, rows, cols);
                    break;
                }
            }
        }
    }
    return;

}
bool isGameOver(int** const arr, const int rows, const int cols)
{
    bool found = true;
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            if (arr[i][j] == 2)
            {
                found = false;
                return found;;
            }             
        }
    }
    return found;     
} 
int main()
{
    setlocale(LC_ALL, "");
    int rows=20, cols=30, k=10, pattern=2;
    int** arr = NULL; //чтобы создать двумерный динамический массив, создаем указатель на массив указателей
    cout << "Введите количество строк и столбцов и число единиц (не равное размеру матрицы - 2): " << endl;    
    //cin >> rows >> cols >> k;
    if (k < (rows * cols)-2)
    {
        bool escape_pressed = false; //для выхода их программы
        bool nowGameOver =false; //глобальная переменная
        arr = CreateArray(rows, cols);
        FillArray(arr, rows, cols, k);
        ShowArray(arr, rows, cols);
        for (int i=1;(!escape_pressed)&&(!nowGameOver);i++)
        {
            nowGameOver = isGameOver(arr, rows, cols);  
            Sleep(70);
            if (i % 5 == 0)
            {
                RandomEnemyMove(arr, rows, cols);
                ShowArray(arr, rows, cols);
            }           
            if (_kbhit())
            {
                switch (_getch()) //if else для проверки переменной
                {
                case 27:
                    escape_pressed = true;
                case 72:
                    ChangeUp(arr, rows, cols);
                    ShowArray(arr, rows, cols);
                    break;
                case 80:
                    ChangeDown(arr, rows, cols);
                    ShowArray(arr, rows, cols);
                    break;

                case 75:
                    ChangeLeft(arr, rows, cols);
                    ShowArray(arr, rows, cols);
                    break;

                case 77:
                    ChangeRight(arr, rows, cols);
                    ShowArray(arr, rows, cols);
                    break;
                }
            }          
        }
        DestroyArray(arr, rows, cols);
    }
    HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE); //для получения дискрипптора
    SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); //белый
    cout << endl;
    cout << "Программа завершена." << endl; 
    return 0;
}








/*void ShowArray(int** const arr, const int rows, const int cols)
const чтобы ф-я гарантированна пробежала по всем эл-ам  массива, в ф-ии мы не сможем никак поменять константные значения
если бы перед arr поставил значения, то я б не смог присвоить никакие зн-я массиву arr*/
/* НЕ СОГЛАСЕН
ТЫ ВЕДЬ УКАЗАТЕЛЬ ПЕРЕДАЁШЬ, А ПО НЕМУ МОЖНО ДОЙТИ ДО НУЖНЫХ ОБЛАСТЕЙ ПАМЯТИ И МЕНЯТЬ ЗНАЧЕНИЯ
& - ТУТ НЕ НУЖЕН, ПЕРЕДАЧА ПО ССЫЛКЕ НЕ ОБЯЗАТЕЛЬНА
const - ТОЖЕ НЕ НУЖЕН, В НЁМ ВООБЩЕ СМЫСЛЕ НЕТ, ТАК КАК ТЕБЕ НУЖНО ПОМЕНЯТЬ ЗНАЧЕНИЯ
int &k - ЗАЧЕМ ПО ССЫЛКЕ ПЕРЕДАВАТЬ? ТЫ ЖЕ НЕ СОБИРАЕШЬСЯ МЕНЯТЬ ЗНАЧЕНИЕ k
void FillArray(int** arr, const int rows, const int cols, int k) - ТАКАЯ СИГНАТУРА НОРМАЛЬНАЯ
                          -- комментарии от Виктора -- */
                          /*const чтобы ф-я гарантированна пробежала по всем эл-ам  массива, в ф-ии мы не сможем никак поменять константные значения
                          если бы перед arr поставил значения, то я б не смог присвоить никакие зн-я массиву arr*/

















